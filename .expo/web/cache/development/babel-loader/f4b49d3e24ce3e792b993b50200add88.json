{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _nativeInterface = _interopRequireDefault(require(\"./nativeInterface\"));\nvar _internetReachability = _interopRequireDefault(require(\"./internetReachability\"));\nvar PrivateTypes = _interopRequireWildcard(require(\"./privateTypes\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar State = (0, _createClass2.default)(function State(configuration) {\n  var _this = this;\n  (0, _classCallCheck2.default)(this, State);\n  _defineProperty(this, \"_nativeEventSubscription\", null);\n  _defineProperty(this, \"_subscriptions\", new Set());\n  _defineProperty(this, \"_latestState\", null);\n  _defineProperty(this, \"_internetReachability\", void 0);\n  _defineProperty(this, \"_handleNativeStateUpdate\", function (state) {\n    _this._internetReachability.update(state);\n\n    var convertedState = _this._convertState(state);\n\n    _this._latestState = convertedState;\n    _this._subscriptions.forEach(function (handler) {\n      return handler(convertedState);\n    });\n  });\n  _defineProperty(this, \"_handleInternetReachabilityUpdate\", function (isInternetReachable) {\n    if (!_this._latestState) {\n      return;\n    }\n    var nextState = (0, _extends2.default)({}, _this._latestState, {\n      isInternetReachable: isInternetReachable\n    });\n    _this._latestState = nextState;\n    _this._subscriptions.forEach(function (handler) {\n      return handler(nextState);\n    });\n  });\n  _defineProperty(this, \"_fetchCurrentState\", function _callee(requestedInterface) {\n    var state, convertedState;\n    return _regenerator.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _regenerator.default.awrap(_nativeInterface.default.getCurrentState(requestedInterface));\n          case 2:\n            state = _context.sent;\n\n            _this._internetReachability.update(state);\n            convertedState = _this._convertState(state);\n            if (!requestedInterface) {\n              _this._latestState = convertedState;\n            }\n            return _context.abrupt(\"return\", convertedState);\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  });\n  _defineProperty(this, \"_convertState\", function (input) {\n    if (typeof input.isInternetReachable === 'boolean') {\n      return input;\n    } else {\n      return (0, _extends2.default)({}, input, {\n        isInternetReachable: _this._internetReachability.currentState()\n      });\n    }\n  });\n  _defineProperty(this, \"latest\", function (requestedInterface) {\n    if (requestedInterface) {\n      return _this._fetchCurrentState(requestedInterface);\n    } else if (_this._latestState) {\n      return Promise.resolve(_this._latestState);\n    } else {\n      return _this._fetchCurrentState();\n    }\n  });\n  _defineProperty(this, \"add\", function (handler) {\n    _this._subscriptions.add(handler);\n\n    if (_this._latestState) {\n      handler(_this._latestState);\n    } else {\n      _this.latest().then(handler);\n    }\n  });\n  _defineProperty(this, \"remove\", function (handler) {\n    _this._subscriptions.delete(handler);\n  });\n  _defineProperty(this, \"tearDown\", function () {\n    if (_this._internetReachability) {\n      _this._internetReachability.tearDown();\n    }\n    if (_this._nativeEventSubscription) {\n      _this._nativeEventSubscription.remove();\n    }\n    _this._subscriptions.clear();\n  });\n\n  this._internetReachability = new _internetReachability.default(configuration, this._handleInternetReachabilityUpdate);\n\n  this._nativeEventSubscription = _nativeInterface.default.eventEmitter.addListener(PrivateTypes.DEVICE_CONNECTIVITY_EVENT, this._handleNativeStateUpdate);\n\n  this._fetchCurrentState();\n});\nexports.default = State;","map":{"version":3,"sources":["state.ts"],"names":["State","Set","constructor","configuration","_internetReachability","InternetReachability","_handleInternetReachabilityUpdate","_nativeEventSubscription","NativeInterface","eventEmitter","addListener","PrivateTypes","DEVICE_CONNECTIVITY_EVENT","_handleNativeStateUpdate","_fetchCurrentState","state","update","convertedState","_convertState","_latestState","_subscriptions","forEach","handler","isInternetReachable","nextState","requestedInterface","getCurrentState","input","currentState","Promise","resolve","add","latest","then","delete","tearDown","remove","clear"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {NativeEventSubscription} from 'react-native';\nimport NativeInterface from './nativeInterface';\nimport InternetReachability from './internetReachability';\nimport * as Types from './types';\nimport * as PrivateTypes from './privateTypes';\n\nexport default class State {\n  private _nativeEventSubscription: NativeEventSubscription | null = null;\n  private _subscriptions = new Set<Types.NetInfoChangeHandler>();\n  private _latestState: Types.NetInfoState | null = null;\n  private _internetReachability: InternetReachability;\n\n  constructor(configuration: Types.NetInfoConfiguration) {\n    // Add the listener to the internet connectivity events\n    this._internetReachability = new InternetReachability(\n      configuration,\n      this._handleInternetReachabilityUpdate,\n    );\n\n    // Add the subscription to the native events\n    this._nativeEventSubscription = NativeInterface.eventEmitter.addListener(\n      PrivateTypes.DEVICE_CONNECTIVITY_EVENT,\n      this._handleNativeStateUpdate,\n    );\n\n    // Fetch the current state from the native module\n    this._fetchCurrentState();\n  }\n\n  private _handleNativeStateUpdate = (\n    state: PrivateTypes.NetInfoNativeModuleState,\n  ): void => {\n    // Update the internet reachability module\n    this._internetReachability.update(state);\n\n    // Convert the state from native to JS shape\n    const convertedState = this._convertState(state);\n\n    // Update the listeners\n    this._latestState = convertedState;\n    this._subscriptions.forEach((handler): void => handler(convertedState));\n  };\n\n  private _handleInternetReachabilityUpdate = (\n    isInternetReachable: boolean | null | undefined,\n  ): void => {\n    if (!this._latestState) {\n      return;\n    }\n\n    const nextState = {\n      ...this._latestState,\n      isInternetReachable,\n    } as Types.NetInfoState;\n    this._latestState = nextState;\n    this._subscriptions.forEach((handler): void => handler(nextState));\n  };\n\n  public _fetchCurrentState = async (\n    requestedInterface?: string,\n  ): Promise<Types.NetInfoState> => {\n    const state = await NativeInterface.getCurrentState(requestedInterface);\n\n    // Update the internet reachability module\n    this._internetReachability.update(state);\n    // Convert and store the new state\n    const convertedState = this._convertState(state);\n    if (!requestedInterface) {\n      this._latestState = convertedState;\n    }\n\n    return convertedState;\n  };\n\n  private _convertState = (\n    input: PrivateTypes.NetInfoNativeModuleState,\n  ): Types.NetInfoState => {\n    if (typeof input.isInternetReachable === 'boolean') {\n      return input as Types.NetInfoState;\n    } else {\n      return {\n        ...input,\n        isInternetReachable: this._internetReachability.currentState(),\n      } as Types.NetInfoState;\n    }\n  };\n\n  public latest = (\n    requestedInterface?: string,\n  ): Promise<Types.NetInfoState> => {\n    if (requestedInterface) {\n      return this._fetchCurrentState(requestedInterface);\n    } else if (this._latestState) {\n      return Promise.resolve(this._latestState);\n    } else {\n      return this._fetchCurrentState();\n    }\n  };\n\n  public add = (handler: Types.NetInfoChangeHandler): void => {\n    // Add the subscription handler to our set\n    this._subscriptions.add(handler);\n\n    // Send it the latest data we have\n    if (this._latestState) {\n      handler(this._latestState);\n    } else {\n      this.latest().then(handler);\n    }\n  };\n\n  public remove = (handler: Types.NetInfoChangeHandler): void => {\n    this._subscriptions.delete(handler);\n  };\n\n  public tearDown = (): void => {\n    if (this._internetReachability) {\n      this._internetReachability.tearDown();\n    }\n\n    if (this._nativeEventSubscription) {\n      this._nativeEventSubscription.remove();\n    }\n\n    this._subscriptions.clear();\n  };\n}\n"]},"metadata":{},"sourceType":"script"}